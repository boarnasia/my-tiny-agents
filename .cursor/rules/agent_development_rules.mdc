---
description: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆtiny_agents.pyï¼‰é–‹ç™ºã®è©³ç´°ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³
globs: 
alwaysApply: false
---
# Agent Development Rules

## ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆtiny_agents.pyï¼‰é–‹ç™ºã®è©³ç´°ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

### 1. ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¯ãƒ©ã‚¹ã®è¨­è¨ˆåŸå‰‡

#### åˆæœŸåŒ–ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼š
```python
class MyTinyAgent:
    def __init__(
        self,
        model_name: str = "openai/gpt-4.1",
        max_context_tokens: int = 16000,
        system_prompt: str = SYSTEM_PROMPT,
        debug: bool = False
    ):
        """ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ–
        
        Args:
            model_name: ä½¿ç”¨ã™ã‚‹LLMãƒ¢ãƒ‡ãƒ«å
            max_context_tokens: æœ€å¤§ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒˆãƒ¼ã‚¯ãƒ³æ•°
            system_prompt: ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
            debug: ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰
        """
```

### 2. ãƒãƒ£ãƒƒãƒˆå±¥æ­´ç®¡ç†

#### å±¥æ­´ã®æ§‹é€ ï¼š
```python
# ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å½¢å¼
message = {
    "role": "user" | "assistant" | "system" | "tool",
    "content": "ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†…å®¹",
    "tool_calls": [...],  # assistantãƒ­ãƒ¼ãƒ«ã®å ´åˆ
    "tool_call_id": "...",  # toolãƒ­ãƒ¼ãƒ«ã®å ´åˆ
    "name": "tool_name"  # toolãƒ­ãƒ¼ãƒ«ã®å ´åˆ
}
```

#### ãƒˆãƒ¼ã‚¯ãƒ³ç®¡ç†ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ï¼š
```python
def _should_trim_history(self, current_tokens: int) -> bool:
    """å±¥æ­´ã®ãƒˆãƒªãƒŸãƒ³ã‚°ãŒå¿…è¦ã‹ãƒã‚§ãƒƒã‚¯"""
    # ãƒãƒƒãƒ•ã‚¡ã‚’è€ƒæ…®ï¼ˆå¿œç­”ç”¨ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç¢ºä¿ï¼‰
    buffer_tokens = 1000
    return current_tokens > (self.max_context_tokens - buffer_tokens)

def _get_trimming_summary(self, trimmed_messages: List[Dict]) -> str:
    """ãƒˆãƒªãƒŸãƒ³ã‚°ã•ã‚ŒãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®è¦ç´„ã‚’ç”Ÿæˆ"""
    user_messages = [m for m in trimmed_messages if m["role"] == "user"]
    assistant_messages = [m for m in trimmed_messages if m["role"] == "assistant"]
    
    return (
        f"[Previous conversation summary: "
        f"{len(user_messages)} user messages and "
        f"{len(assistant_messages)} assistant responses were trimmed]"
    )
```

### 3. ãƒ„ãƒ¼ãƒ«å‘¼ã³å‡ºã—ã®å‡¦ç†

#### ãƒ„ãƒ¼ãƒ«å‘¼ã³å‡ºã—ã®ãƒ•ãƒ­ãƒ¼ï¼š
```python
async def _handle_tool_calls(
    self,
    tool_calls: List[Any],
    messages: List[Dict[str, Any]]
) -> List[Dict[str, Any]]:
    """ãƒ„ãƒ¼ãƒ«å‘¼ã³å‡ºã—ã‚’å‡¦ç†"""
    tool_results = []
    
    for tool_call in tool_calls:
        # 1. ãƒ„ãƒ¼ãƒ«ã®æ¤œè¨¼
        if tool_call.function.name not in self.tool_to_session:
            tool_results.append({
                "role": "tool",
                "tool_call_id": tool_call.id,
                "name": tool_call.function.name,
                "content": "Error: Tool not found"
            })
            continue
        
        # 2. å¼•æ•°ã®ãƒ‘ãƒ¼ã‚¹
        try:
            args = json.loads(tool_call.function.arguments)
        except json.JSONDecodeError as e:
            tool_results.append({
                "role": "tool",
                "tool_call_id": tool_call.id,
                "name": tool_call.function.name,
                "content": f"Error: Invalid arguments - {str(e)}"
            })
            continue
        
        # 3. ãƒ„ãƒ¼ãƒ«ã®å®Ÿè¡Œ
        session = self.tool_to_session[tool_call.function.name]
        try:
            result = await session.call_tool(tool_call.function.name, args)
            content = result.content[0].text if result.content else "No content"
            
            tool_results.append({
                "role": "tool",
                "tool_call_id": tool_call.id,
                "name": tool_call.function.name,
                "content": content
            })
        except Exception as e:
            tool_results.append({
                "role": "tool",
                "tool_call_id": tool_call.id,
                "name": tool_call.function.name,
                "content": f"Error: {str(e)}"
            })
    
    return tool_results
```

### 4. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°æˆ¦ç•¥

#### éšå±¤çš„ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ï¼š
```python
class AgentError(Exception):
    """ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåŸºåº•ä¾‹å¤–"""
    pass

class ModelError(AgentError):
    """ãƒ¢ãƒ‡ãƒ«é–¢é€£ã®ã‚¨ãƒ©ãƒ¼"""
    pass

class ToolError(AgentError):
    """ãƒ„ãƒ¼ãƒ«å®Ÿè¡Œã‚¨ãƒ©ãƒ¼"""
    pass

class ConnectionError(AgentError):
    """æ¥ç¶šã‚¨ãƒ©ãƒ¼"""
    pass

async def safe_process_query(self, query: str) -> str:
    """å®‰å…¨ãªã‚¯ã‚¨ãƒªå‡¦ç†"""
    try:
        return await self.process_query(query)
    except ModelError as e:
        return f"âš ï¸ ãƒ¢ãƒ‡ãƒ«ã‚¨ãƒ©ãƒ¼: {str(e)}\nãƒ¢ãƒ‡ãƒ«è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚"
    except ToolError as e:
        return f"ğŸ”§ ãƒ„ãƒ¼ãƒ«ã‚¨ãƒ©ãƒ¼: {str(e)}\nãƒ„ãƒ¼ãƒ«ã®å®Ÿè¡Œã«å¤±æ•—ã—ã¾ã—ãŸã€‚"
    except ConnectionError as e:
        return f"ğŸŒ æ¥ç¶šã‚¨ãƒ©ãƒ¼: {str(e)}\nãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚"
    except Exception as e:
        return f"âŒ äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼: {str(e)}\nè©³ç´°ã¯ãƒ­ã‚°ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚"
```

### 5. éåŒæœŸå‡¦ç†ã®ãƒ‘ã‚¿ãƒ¼ãƒ³

#### ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå‡¦ç†ï¼š
```python
async def _call_model_with_timeout(
    self,
    messages: List[Dict[str, Any]],
    tools: Optional[List[Dict[str, Any]]] = None,
    timeout: float = 30.0
) -> Any:
    """ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ããƒ¢ãƒ‡ãƒ«å‘¼ã³å‡ºã—"""
    try:
        return await asyncio.wait_for(
            self._call_model(messages, tools),
            timeout=timeout
        )
    except asyncio.TimeoutError:
        raise ModelError(f"Model call timed out after {timeout} seconds")
```

#### ä¸¦è¡Œã‚µãƒ¼ãƒãƒ¼æ¥ç¶šï¼š
```python
async def connect_to_multiple_servers_parallel(
    self,
    server_paths: List[str]
) -> None:
    """è¤‡æ•°ã‚µãƒ¼ãƒãƒ¼ã«ä¸¦è¡Œæ¥ç¶š"""
    tasks = []
    for server_path in server_paths:
        task = asyncio.create_task(
            self._connect_with_retry(server_path)
        )
        tasks.append(task)
    
    results = await asyncio.gather(*tasks, return_exceptions=True)
    
    for server_path, result in zip(server_paths, results):
        if isinstance(result, Exception):
            print(f"Failed to connect to {server_path}: {result}")
        else:
            print(f"Successfully connected to {server_path}")
```

### 6. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

#### ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºï¼š
```python
def _format_prompt(self, prompt_type: str = "query") -> str:
    """ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
    prompts = {
        "query": "\nğŸ¤– Query: ",
        "confirm": "\nâ“ Confirm (yes/no): ",
        "retry": "\nğŸ”„ Retry query: "
    }
    return prompts.get(prompt_type, "\n> ")

async def chat_loop_enhanced(self):
    """æ‹¡å¼µãƒãƒ£ãƒƒãƒˆãƒ«ãƒ¼ãƒ—"""
    print("ğŸš€ My Tiny Agent Started!")
    print(f"ğŸ“Š Model: {self.model_name}")
    print(f"ğŸ’¾ Max tokens: {self.max_context_tokens}")
    print("ğŸ’¡ Commands: 'quit', 'clear', 'history', 'help'")
    
    while True:
        try:
            query = input(self._format_prompt("query")).strip()
            
            # ã‚³ãƒãƒ³ãƒ‰å‡¦ç†
            if query.lower() == "help":
                self._show_help()
                continue
            # ... ä»–ã®ã‚³ãƒãƒ³ãƒ‰å‡¦ç†
            
        except KeyboardInterrupt:
            print("\nğŸ‘‹ Interrupted. Type 'quit' to exit.")
            continue
```

### 7. çŠ¶æ…‹ç®¡ç†

#### ã‚»ãƒƒã‚·ãƒ§ãƒ³çŠ¶æ…‹ï¼š
```python
@dataclass
class SessionState:
    """ã‚»ãƒƒã‚·ãƒ§ãƒ³çŠ¶æ…‹"""
    start_time: datetime
    message_count: int = 0
    token_count: int = 0
    tool_calls_count: int = 0
    errors_count: int = 0
    
    def increment_messages(self):
        self.message_count += 1
    
    def get_duration(self) -> timedelta:
        return datetime.now() - self.start_time
    
    def get_summary(self) -> str:
        duration = self.get_duration()
        return (
            f"Session: {duration.total_seconds():.0f}s, "
            f"Messages: {self.message_count}, "
            f"Tokens: {self.token_count}, "
            f"Tools: {self.tool_calls_count}, "
            f"Errors: {self.errors_count}"
        )
```

### 8. æ‹¡å¼µæ€§ã®è€ƒæ…®

#### ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ ï¼š
```python
class AgentPlugin:
    """ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®åŸºåº•ã‚¯ãƒ©ã‚¹"""
    
    async def on_query_start(self, query: str) -> Optional[str]:
        """ã‚¯ã‚¨ãƒªé–‹å§‹æ™‚ã®ãƒ•ãƒƒã‚¯"""
        return query
    
    async def on_response_ready(self, response: str) -> str:
        """å¿œç­”æº–å‚™å®Œäº†æ™‚ã®ãƒ•ãƒƒã‚¯"""
        return response
    
    async def on_error(self, error: Exception) -> Optional[str]:
        """ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚ã®ãƒ•ãƒƒã‚¯"""
        return None

class LoggingPlugin(AgentPlugin):
    """ãƒ­ã‚®ãƒ³ã‚°ãƒ—ãƒ©ã‚°ã‚¤ãƒ³"""
    
    async def on_query_start(self, query: str) -> Optional[str]:
        logger.info(f"Query received: {query[:50]}...")
        return query
    
    async def on_error(self, error: Exception) -> Optional[str]:
        logger.error(f"Error occurred: {error}", exc_info=True)
        return f"An error occurred. Please try again."
```

### 9. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

#### ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ï¼š
```python
async def process_query_streaming(
    self,
    query: str,
    callback: Callable[[str], None]
) -> None:
    """ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å¿œç­”å‡¦ç†"""
    # ãƒ„ãƒ¼ãƒ«å‘¼ã³å‡ºã—ã®å‡¦ç†
    tool_responses = await self._process_tools(query)
    
    # ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å¿œç­”
    async for chunk in self._stream_model_response(messages):
        callback(chunk)
```

#### ãƒ¡ãƒ¢ãƒªåŠ¹ç‡ï¼š
```python
def _cleanup_old_sessions(self):
    """å¤ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
    if len(self.mcp_client_sessions) > 10:
        # æœ€ã‚‚å¤ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’é–‰ã˜ã‚‹
        oldest = self.mcp_client_sessions.pop(0)
        asyncio.create_task(oldest.close())
```

### 10. ãƒ†ã‚¹ãƒˆå®¹æ˜“æ€§

#### ãƒ¢ãƒƒã‚¯ã‚µãƒãƒ¼ãƒˆï¼š
```python
class MockSession:
    """ãƒ†ã‚¹ãƒˆç”¨ãƒ¢ãƒƒã‚¯ã‚»ãƒƒã‚·ãƒ§ãƒ³"""
    
    def __init__(self, tools: List[Dict]):
        self.tools = tools
    
    async def call_tool(self, name: str, args: Dict) -> Any:
        """ãƒ¢ãƒƒã‚¯ãƒ„ãƒ¼ãƒ«å‘¼ã³å‡ºã—"""
        return MockToolResult(content=[MockContent(text="Mock result")])

# ãƒ†ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã§ã®åˆæœŸåŒ–
if os.getenv("AGENT_TEST_MODE"):
    agent = MyTinyAgent(model_name="test/mock-model")
    agent.mcp_client_sessions = [MockSession(mock_tools)]
``` 